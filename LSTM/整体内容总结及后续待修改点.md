# LSTM_twotarget .ipynb 整体内容总结及后续待修改点

## 📋 项目概述

这是一个基于**LSTM神经网络**和**双重注意力机制**的股票/指数价格预测系统，主要用于预测恒生指数（HSI）的未来走势。系统通过识别大量交易模式（Patterns）来预测**1天后的收益率**和**波动率**（双目标预测）。

**当前实现状态**：
- ✅ 已实现：多时间间隔预测（1天、5天、10天、15天、20天、25天、30天收益率 + 波动率）
- ✅ 模型同时输出7个时间间隔的收益率和1个波动率（共8维输出）

---

## 🏗️ 整体架构流程

### **STEP 0: 数据获取与预处理**
- **数据源**: 使用 `yfinance` 获取股票/指数数据
- **默认标的**: 恒生指数（^HSI），支持用户自定义输入
- **数据范围**: 默认获取20年历史数据
- **外部数据整合**（多品种适配 + 期货数据）:
  - **波动率指数（VIX）**：优先使用美股VIX（^VIX），失败则尝试港股HSIL（^HSIL），都失败则用主标的自身波动率估算
  - **股票指数**：标普500（^GSPC）、上证指数（000001.SS）
  - **外汇**：美元/人民币期货（CNH=F）、美元/港币（HKD=X）、美元指数（DX-Y.NYB）
  - **利率**：10年期美债（^TNX）
  - **商品期货**：
    - 黄金期货（GC=F）
    - 白银期货（SI=F）
    - WTI原油期货（CL=F）
    - 铜期货（HG=F）
    - 天然气期货（NG=F）
  - **股指期货**（领先指标）：
    - E-mini S&P 500期货（ES=F）- 近月合约
    - E-mini Nasdaq-100期货（NQ=F）- 近月合约
    - E-mini Dow Jones期货（YM=F）- 近月合约
    - **不同到期日期货**（基于期限结构推断）：
      - ES 15天到期期货（ES_15D_Close）
      - ES 1个月到期期货（ES_1M_Close）
      - NQ 15天到期期货（NQ_15D_Close）
      - NQ 1个月到期期货（NQ_1M_Close）
      - ⚠️ **注意**：由于yfinance限制，15天和1个月期货价格通过期限结构（Term Structure）推断得出
  - **国债期货**：
    - 30年期美债期货（ZB=F）
    - 10年期美债期货（ZN=F）
  - **外汇期货**：
    - 欧元/美元期货（6E=F）
    - 美元/日元期货（6J=F）
  - **容错处理**：所有外部数据缺失时，相关特征自动设为0或中性值，确保多品种兼容
- **数据清洗**: 
  - 处理缺失值（使用前向填充，避免未来数据泄露）
  - 过滤零成交量数据（保留最近3天）
  - 计算收益率和外部资产收益率

---

### **STEP 1: 交易模式识别（Pattern Detection）**
核心函数：`detect_trading_patterns(df)`

生成 **120+ 个交易模式特征**，涵盖以下类别：
- 基础技术指标（收益率、波动率、跳空缺口）
- 成交量因子（双时间窗口、量价关系）
- 技术分析指标（RSI、MACD、布林带、KDJ、ADX）
- 形态识别（反转、突破、趋势连续性）
- 市场情绪因子（VIX相关、跨市场相关性）
- 宏观金融因子（汇率、利率、美元指数）
- **期货领先指标**（ES/SPX价差、股指期货相关性、商品期货相关性）⭐ **新增**
- **不同到期日期货特征**（15天、1个月）⭐ **新增**：
  - 期限结构斜率（ES_Term_Structure_Slope, NQ_Term_Structure_Slope）
  - 不同到期日期货价差（ES_Front_15D_Spread, ES_1M_15D_Spread）
  - 不同到期日期货收益率相关性（Corr_ES_15D_60, Corr_ES_1M_60）
  - ES/SPX基差（ES_SPX_Basis）及变化率
- 聪明钱指标（CMF、OBV、MFI）
- 统计特征（偏度、峰度、变异系数）
- 市场分形（Choppiness Index、趋势效率）
- 时间特征（月份周期性、季度哑变量）

---

### **STEP 1.5: 动态特征筛选系统** ⭐ **最新完成**

#### **核心流程：全局扫描 → 共线性剪枝 → Permutation Importance评估 → 并集保留策略 → 逻辑截断**

#### **阶段1：全局扫描 (Global Feature Scanning)**
- 评估所有特征的重要性
- 准备目标变量（收益率和波动率）
- 数据对齐和清洗

#### **阶段2：共线性剪枝 (Collinearity Pruning)**
- 计算特征相关性矩阵
- 去除高度相关的冗余特征（相关系数 > 0.95）
- 保留方差更大的特征（信息量更丰富）
- 输出剪枝统计信息

#### **阶段3：Permutation Importance评估 (Permutation Importance Evaluation)** ⭐ **核心改进**
- **核心方法切换**：从MDI（Mean Decrease Impurity）改为Permutation Importance
  - **MDI问题**：基于不纯度减少量，可能高估高基数特征的重要性
  - **Permutation Importance优势**：基于模型预测能力下降量，更直接反映特征对预测的实际贡献
  - **稳定性增强**：使用`n_repeats=10`多次打乱取均值，消除随机性干扰
  - **标准差评估**：计算重要性标准差，评估稳定性

- **步骤1：Permutation Importance计算**
  - 训练收益率模型（RandomForest）
  - 训练波动率模型（RandomForest）
  - 使用`sklearn.inspection.permutation_importance`计算置换重要性
  - 分别计算收益率和波动率的Permutation Importance（独立评估）
  - 同时保留MDI用于对比分析
  - 计算初始R²表现

- **步骤2：动态权重计算（仅用于展示）**
  - 根据模型R²表现自动调整权重
  - 权重范围限制在 [0.2, 0.8]（防止极端权重）
  - 表现更好的目标变量获得更高权重
  - 公式：`weight_returns = clip(abs(r2_returns) / (abs(r2_returns) + abs(r2_volatility)), 0.2, 0.8)`
  - **注意**：动态权重仅用于展示和日志，不再用于特征重要性加权

- **步骤3：并集保留策略（Union Strategy）** ⭐ **核心改进**
  - **策略说明**：不再使用动态权重加权混合两个任务的重要性，而是确保两个任务的Top因子都进入决赛圈
  - **实现方法**：
    - 收益率任务：取Permutation Importance Top 40特征
    - 波动率任务：取Permutation Importance Top 40特征
    - 合并去重：取两个任务Top 40特征的并集（通常60-70个特征）
  - **优势**：
    - 避免一方特征数量枯竭（收益率和波动率是不同的物理量）
    - 确保两个任务的重要特征都被保留
    - 更直观和可解释

#### **阶段4：逻辑截断 (Logical Truncation) - 作用于并集后的特征集**
- **作用范围**：在并集得到的特征集（通常60-70个特征）上运行逻辑截断
- **综合重要性计算**：使用两个任务的平均Permutation Importance作为综合重要性
  - `importance_combined = (importance_returns_perm + importance_volatility_perm) / 2.0`
- **策略1：重要性分布分析**
  - 计算重要性下降的拐点（elbow point）
  - 识别重要性下降最陡的点
  
- **策略2：累积重要性分析**
  - 计算累积重要性百分比
  - 保留累积重要性达到80%的特征
  
- **策略3：性能验证（边际收益测试）**
  - 在并集特征集上测试不同特征数量（30, 40, 50, 60, 70, 80）的模型性能
  - 找到性能提升的拐点（边际收益递减点）
  - 识别R²提升小于0.001的点
  - 剔除那些虽然入选但对模型几乎没有边际贡献的特征
  
- **策略4：综合决策**
  - 综合考虑：拐点、累积80%重要性、性能最优、默认值（60）
  - 使用中位数方法确定最终特征数（更稳健）
  - 限制在合理范围 [30, 80]

#### **可视化增强** ⭐ **新增MDI vs Permutation对比图**
- **新增散点对比图**：
  - MDI vs Permutation Importance（收益率任务）
  - MDI vs Permutation Importance（波动率任务）
  - 标注左上角的特征（被低估的黑马：MDI低但Permutation高）
  - 添加对角线（y=x）作为参考线
- **Permutation Importance可视化**：
  - Top 30特征条形图（带误差条显示标准差）
  - 分别显示收益率和波动率的Permutation Importance
- **并集特征可视化**：
  - 并集特征重要性分布直方图
  - 逻辑截断阈值可视化
- **性能对比图**：不同特征数量的R²表现
- **特征相关性热图**：筛选后的Top特征相关性

#### **性能评估**
- 显示筛选前后的R²对比
- 显示特征保留率和累积重要性
- 显示性能变化（提升/下降）
- 显示并集特征数和重叠特征数

#### **元数据保存**
- 保存筛选后的特征列表：`./model_artifacts/selected_features.json`
- 保存特征筛选元数据：`./model_artifacts/feature_selection_metadata.json`
  - 包含：原始特征数、共线性剪枝后特征数、并集特征数、最终特征数
  - 包含：动态权重（仅用于展示）、逻辑截断参数
  - 包含：方法标记（`permutation_importance_union`）、`top_n_union`、`n_repeats`

**最终输出**：
- 筛选后的特征列表（通常30-80个特征）
- 动态权重值（收益率权重、波动率权重，仅用于展示）
- Permutation Importance结果（包含均值和标准差）
- MDI vs Permutation Importance对比分析
- 性能评估报告
- 可视化图表（包含MDI vs Permutation散点对比图）

---

### **STEP 2: 数据准备与序列构建**
- **目标变量**: 多时间间隔收益率（百分比）+ 波动率（百分比）
  - **收益率目标**：7个时间间隔的收益率（1天、5天、10天、15天、20天、25天、30天）
  - **波动率目标**：1天后的波动率（用于量化不确定性）
  - 计算公式：
    ```python
    PREDICTION_HORIZONS = [1, 5, 10, 15, 20, 25, 30]  # 7个时间间隔
    for horizon in PREDICTION_HORIZONS:
        target_returns_dict[f'Target_Returns_{horizon}D'] = df['Close'].pct_change(horizon).shift(-horizon) * 100
    ```
  - **y_raw维度**：8列 = [7个时间间隔收益率, 波动率]
- **数据划分**: 
  - 训练集：80%
  - 测试集：20%
  - **严格按时间顺序划分**（避免未来数据泄露）
- **标准化**: 
  - 特征：使用 `StandardScaler`，仅在训练集上拟合
  - 收益率：为每个时间间隔创建独立的`StandardScaler`（字典形式：`scaler_target_returns[horizon]`）
  - 波动率：使用 `log1p + StandardScaler`（处理右偏性）
- **序列构建**: 
  - 序列长度：30天
  - 滑动窗口方式创建时间序列
  - 测试集前拼接训练集最后30天，确保序列完整性

---

### **STEP 3: 模型构建与训练**

#### **模型架构：DualTowerPatternAwareLSTM（多时间间隔输出）**
```python
class DualTowerPatternAwareLSTM(nn.Module):
    - Pattern Attention Layer: 特征级注意力（60个特征，动态筛选后）
    - LSTM Layer: 1层LSTM，隐藏层64维
    - Multi-Scale Time Attention: 多时间尺度注意力（短期、中期、长期）
    - Output Layer: 
      - 收益率塔：输出7个时间间隔的收益率（1, 5, 10, 15, 20, 25, 30天）
        - `nn.Linear(hidden_size // 2, NUM_HORIZONS)`  # NUM_HORIZONS = 7
      - 波动率塔：输出1个波动率值（用于量化不确定性）
    - 最终输出维度：8维 = [7个收益率, 1个波动率]
    - Dropout: 0.4
```

#### **训练配置**
- **优化器**: AdamW（学习率0.0003，权重衰减5e-4）
- **损失函数**: 加权MSE（多时间间隔 + 波动率 + 方向）
  - 收益率损失：7个时间间隔的加权MSE
    - 权重：`[1.0, 0.8, 0.6, 0.5, 0.4, 0.3, 0.2]`（短期权重更高）
    - 公式：`loss_returns = Σ(horizon_weights[i] × MSE(pred[i], target[i])) / sum(horizon_weights)`
  - 波动率损失：1个波动率的MSE
  - 方向损失：1天收益率的方向准确率（Binary Cross-Entropy，仅使用1天收益率）
  - 总损失 = LOSS_WEIGHT_RETURNS × 收益率损失 + LOSS_WEIGHT_VOLATILITY × 波动率损失 + LOSS_WEIGHT_DIRECTION × 方向损失
- **学习率调度**: ReduceLROnPlateau（patience=20）
- **早停机制**: patience=12
- **训练轮数**: 最多100轮
- **批次大小**: 128

#### **模型保存**
- 保存最佳模型权重：`./model_artifacts/best_model.pth`
- 保存模型配置：`./model_artifacts/model_config.json`
- 包含：num_patterns, hidden_size, num_layers, dropout, sequence_length, learning_rate, batch_size, **num_horizons, prediction_horizons**, best_epoch, best_val_loss
- 保存scaler：
  - `scaler_target_returns.pkl`：字典形式，包含7个时间间隔的scaler
  - `scaler_target_volatility.pkl`：波动率scaler

---

### **STEP 4: 模型分析与评估**
- **多时间间隔预测评估**: 
  - 为每个时间间隔（1, 5, 10, 15, 20, 25, 30天）分别计算评估指标
  - MAE, RMSE, R²（每个时间间隔独立计算）
  - 输出格式：
    ```
    【1天收益率预测】
      Train: MAE=..., MSE=..., R²=...
      Test:  MAE=..., MSE=..., R²=...
    【5天收益率预测】
      ...
    ```
- **方向准确率**: 计算1天预测方向正确率（仅使用1天收益率）
- **反标准化**: 为每个时间间隔分别反标准化（使用对应的scaler）
- **注意力分析**: 模式重要性和时间注意力分布
- **波动率预测评估**: 波动率预测的MAE, RMSE, R²

---

### **STEP 5: 模式注意力分析**
- **模式重要性排名**: 分析哪些交易模式最受模型关注
- **Top 10 重要模式**: 显示最重要的特征及其注意力权重
- **时间注意力分析**: 模型最关注的历史时间点
- **多时间尺度注意力分析**: 分析短期、中期、长期时间尺度的注意力权重分布

---

### **STEP 6: 综合可视化**
生成多个子图：
1. Top 10模式重要性条形图
2. 模式注意力热力图
3. 多时间尺度注意力分布（短期、中期、长期）
4. 训练损失曲线（总损失、收益率损失、波动率损失、方向损失）
5. 预测 vs 实际散点图（1天收益率，用于方向准确率分析）
6. 时序预测对比
7. 模式类别重要性
8. 注意力权重分布直方图
- **多时间间隔评估输出**：在STEP 4中为每个时间间隔分别输出评估指标

---

### **STEP 7: 自回归预测（未来N天）**
- **预测方式**: 自回归循环（Autoregressive）+ 蒙特卡洛模拟
- **流程**:
  1. 使用最新30天历史数据生成特征
  2. **模型预测输出**：
     - 7个时间间隔的收益率（pred_returns_denorm，包含1, 5, 10, 15, 20, 25, 30天）
     - 1个波动率值（pred_vol_pct）
  3. **自回归策略**：
     - 使用1天预测（pred_returns_denorm[0]）进行自回归循环
     - 其他时间间隔（5, 10, 15, 20, 25, 30天）的预测可用于验证或更复杂的策略
  4. **蒙特卡洛模拟**：
     - 使用1天预测收益率作为均值（mu = pred_returns_denorm[0]）
     - 使用预测波动率（按时间平方根缩放）作为标准差（sigma）
     - 生成N次随机收益率：`random_returns = np.random.normal(loc=mu, scale=sigma, size=MONTE_CARLO_SIMULATIONS)`
     - 计算对应的价格分布：`simulated_prices = last_close_price * (1 + random_returns / 100)`
     - 使用中位数作为单一预测价格（更稳健）
  5. 将新价格加入历史数据
  6. 动态重新计算所有特征（使用筛选后的特征集）
  7. 重复步骤1-6，预测N天
- **波动率的作用**：
  - **量化不确定性**：波动率作为蒙特卡洛模拟的标准差，反映预测的不确定性
  - **生成价格分布**：通过蒙特卡洛模拟生成价格分布，而不是单一价格点
  - **计算置信区间**：通过模拟结果的分位数（如5%、50%、95%）计算置信区间
  - **风险评估**：高波动率意味着更大的价格波动范围，低波动率意味着更稳定的预测
  - **时间缩放**：多天预测时，波动率按时间平方根缩放（√T规则）
- **关键特性**:
  - 动态特征工程（每天重新计算所有特征）
  - 单时间间隔预测（1天，当前实现）
  - 蒙特卡洛模拟（默认1000次模拟）
  - 置信区间可视化（显示5%、50%、95%分位数）
  - 展示每天的Top 10模式注意力
  - 生成未来N天的价格预测表和图表
  - 特征对齐机制（确保特征数量一致）

---

### **STEP 8: 场景回测（Scenario Backtesting）**

#### **核心改进**
- **使用STEP 3预训练模型**：不再为每个场景重新训练，而是加载STEP 3训练好的模型
- **特征筛选集成**：优先加载STEP 1.5保存的`selected_features.json`，确保特征一致性
- **特征对齐机制**：确保自回归预测过程中特征数量一致
- **多时间间隔支持**：
  - 构建7个时间间隔的目标变量（与STEP 2一致）
  - 为每个时间间隔创建独立的scaler（字典形式）
  - 使用DualTowerPatternAwareLSTM模型（支持多时间间隔输出）
  - 使用combined_loss损失函数（多时间间隔加权MSE）
  - 预测结果提取：提取7个时间间隔的收益率，使用1天预测进行自回归

#### **三种场景分析**

**场景1: 保留30天验证集**
- 训练截止：最新日期前30个交易日
- 验证集：30天
- 未来预测：10天（可配置）
- **评估**：1天预测的MAE、RMSE、R²（当前实现）

**场景2: 保留15天验证集**
- 训练截止：最新日期前15个交易日
- 验证集：15天
- 未来预测：10天（可配置）
- **评估**：1天预测的MAE、RMSE、R²（当前实现）

**场景3: 全数据训练**
- 训练截止：最新日期
- 验证集：0天（直接预测未来）
- 未来预测：10天（可配置）
- **评估**：1天预测的MAE、RMSE、R²（当前实现）

#### **评估指标**
- **MAE**（平均绝对误差）: 评估验证集预测精度（1天收益率）
- **RMSE**: 均方根误差（1天收益率）
- **R²**: 决定系数（1天收益率）
- **方向准确率**: 1天预测方向正确率
- **Top 10模式注意力**: 每个场景下模型关注的重点（每天）
- **时间注意力峰值**: 模型最关注的历史时间点

#### **输出内容**
- 对比图表：
  1. 历史价格 vs 三种场景预测（1天）
  2. 验证集回测对比
  3. MAE误差对比
  4. RMSE误差对比
  5. R²性能对比
  6. 未来预测对比
- OHLCV预测表（未来N天）
- 综合对比报告
- 每天预测的Top 10 Pattern重要性

---

### **STEP 9: 多时间间隔预测可视化** ⭐
- **功能**: 可视化不同时间间隔的预测结果（1天、15天、30天），考虑volatility不确定性
- **主要特性**:
  1. **多时间间隔预测**: 直接使用模型输出的多时间间隔预测值（1, 5, 10, 15, 20, 25, 30天）
  2. **可视化时间间隔**: 选择1天、15天、30天进行可视化（对应PREDICTION_HORIZONS中的索引0, 2, 6）
  3. **考虑Volatility**: 使用蒙特卡洛模拟生成置信区间
  4. **价格走势连线**: 将预测结果连成一条线，展示价格走势
  5. **可视化内容**:
     - 历史价格 + 预测路径（1天、15天、30天，直接使用模型输出）
     - 置信区间（5%-95%）填充区域
     - 波动率变化图
     - 收益率对比图（柱状图，显示所有7个时间间隔的预测）
  6. **模型加载**: 自动加载STEP 3训练好的模型和scaler（字典形式）
- **Volatility的作用**:
  - **量化不确定性**: 作为蒙特卡洛模拟的标准差（sigma），反映预测的不确定性
  - **生成价格分布**: 通过蒙特卡洛模拟生成价格分布，而不是单一价格点
  - **计算置信区间**: 通过模拟结果的分位数（如5%、50%、95%）计算置信区间
  - **风险评估**: 高波动率意味着更大的价格波动范围，低波动率意味着更稳定的预测
- **输出内容**:
  - 多时间间隔价格预测路径图（包含置信区间）
  - 波动率变化图
  - 收益率对比图
  - 预测摘要报告（包含价格、置信区间、波动率）

---

## 🔑 核心技术特点

### 1. **双重注意力机制**
- **Pattern Attention**: 自动识别哪些交易模式最重要
- **Time Attention**: 自动识别哪些历史时间点最相关

### 2. **Permutation Importance特征筛选系统** ⭐ **核心改进**
- **全局扫描**: 评估所有特征
- **共线性剪枝**: 去除冗余特征
- **Permutation Importance评估**: 基于模型预测能力下降量，更直接反映特征对预测的实际贡献
  - 使用`n_repeats=10`多次打乱取均值，消除随机性干扰
  - 分别计算收益率和波动率的Permutation Importance（独立评估）
  - 同时保留MDI用于对比分析
- **并集保留策略**: 各取Top 40特征，合并去重，确保两个任务的重要特征都被保留
- **逻辑截断**: 基于多指标自动确定最优特征数，作用于并集后的特征集
- **MDI vs Permutation对比**: 可视化对比两种方法，识别被低估的黑马特征

### 3. **严格的数据泄露防护**
- 外部数据强制滞后1期
- 仅使用前向填充（ffill），禁用后向填充（bfill）
- 严格按时间顺序划分训练/测试集
- 特征标准化仅在训练集上拟合

### 4. **多时间间隔预测 + 蒙特卡洛模拟**
- 动态特征工程（每天重新计算所有特征）
- **多目标预测**：同时预测7个时间间隔的收益率（1, 5, 10, 15, 20, 25, 30天）和波动率
- **加权损失函数**：短期时间间隔权重更高（1.0），长期权重递减（0.2）
- **蒙特卡洛模拟**：使用预测波动率作为标准差，生成价格分布
- **置信区间**：通过模拟结果计算5%、50%、95%分位数
- **多时间点可视化**：STEP 9直接使用模型输出的多时间间隔预测值（1, 15, 30天）
- **自回归策略**：使用1天预测进行自回归循环，其他时间间隔用于验证
- 完整的OHLCV数据生成
- 特征对齐机制（确保特征数量一致）

### 5. **多场景验证**
- 不同训练集长度对比
- 验证集回测评估
- 未来预测一致性检查
- 使用预训练模型（STEP 3）
- 特征一致性保证（优先加载STEP 1.5保存的特征列表）

---

## 📊 关键参数配置

| 参数 | 值 | 说明 |
|------|-----|------|
| 序列长度 | 30天 | LSTM输入窗口 |
| 隐藏层维度 | 64 | LSTM隐藏层大小 |
| LSTM层数 | 1 | 深度 |
| Dropout | 0.4 | 防止过拟合 |
| 学习率 | 0.0003 | 初始学习率 |
| 批次大小 | 128 | 训练批次 |
| 训练轮数 | 100 | 最大训练轮数 |
| 早停耐心 | 20 | 验证损失不改善的容忍轮数 |
| 预测天数 | 10-15天 | STEP 7/8预测范围（可配置） |
| 特征数量 | 30-80 | 动态筛选后（默认60） |
| 共线性阈值 | 0.95 | 相关系数阈值 |
| 权重范围 | [0.2, 0.8] | 动态权重限制范围 |
| 预测时间间隔 | [1, 5, 10, 15, 20, 25, 30]天 | 7个时间间隔，模型同时输出 |
| 时间间隔权重 | [1.0, 0.8, 0.6, 0.5, 0.4, 0.3, 0.2] | 短期权重更高 |
| 蒙特卡洛模拟次数 | 1000 | STEP 7/9默认模拟次数 |
| 置信区间 | 5%, 50%, 95% | 通过蒙特卡洛模拟计算 |
| 模型输出维度 | 8 | 7个收益率 + 1个波动率 |
| Scaler数量 | 8 | 7个收益率scaler（字典）+ 1个波动率scaler |

---

## ⚠️ 后续待修改点

### 🔴 **高优先级 - 多时间间隔预测代码修改** ⭐ **已完成** ✅

**当前状态**：模型已实现多时间间隔输出（7个时间间隔的收益率 + 1个波动率）

**实现内容**：已完成STEP 2-9的所有相关修改，模型现在同时输出7个时间间隔的收益率和1个波动率。

#### **STEP 2: 数据准备与序列构建 - 多时间间隔目标变量** ✅ **已完成**

**已实现的内容**：

1. **目标变量构建** ✅
   - 已构建7个时间间隔的收益率目标（1天、5天、10天、15天、20天、25天、30天）
   - 使用`PREDICTION_HORIZONS = [1, 5, 10, 15, 20, 25, 30]`定义时间间隔
   - 使用字典形式存储：`target_returns_dict[f'Target_Returns_{horizon}D']`

2. **目标变量标准化** ✅
   - 为每个时间间隔创建独立的scaler（字典形式：`scaler_target_returns[horizon]`）
   - 分别标准化每个时间间隔的收益率
   - 保存为字典形式到`scaler_target_returns.pkl`

3. **y_raw构建** ✅
   - y_raw现在是8列：[1天收益率, 5天收益率, ..., 30天收益率, 波动率]
   - 使用`target_columns = list(target_returns.columns) + ['Target_Volatility']`构建

#### **STEP 3: 模型构建与训练 - 多时间间隔输出** ✅ **已完成**

**已实现的内容**：

1. **模型输出层** ✅
   - 已修改为：`nn.Linear(hidden_size // 2, NUM_HORIZONS)` - 输出7个时间间隔的收益率
   - NUM_HORIZONS = 7

2. **损失函数** ✅
   - 已实现7个时间间隔的加权MSE
   - 权重设置：`horizon_weights = [1.0, 0.8, 0.6, 0.5, 0.4, 0.3, 0.2]`（短期权重更高）
   - 方向损失仅使用1天收益率（`pred_returns[:, 0:1]`）
   - 模型配置保存包含`num_horizons`和`prediction_horizons`

#### **STEP 4: 模型分析与评估 - 多时间间隔评估** ✅ **已完成**

**已实现的内容**：

1. **预测结果提取** ✅
   - 已修改为：`test_pred[:, 0:NUM_HORIZONS]` - 提取7个时间间隔的收益率
   - 波动率：`test_pred[:, NUM_HORIZONS:NUM_HORIZONS+1]`

2. **评估指标计算** ✅
   - 为每个时间间隔分别计算MAE, RMSE, R²
   - 输出格式包含所有7个时间间隔的评估结果
   - 方向准确率仅使用1天收益率

3. **反标准化** ✅
   - 为每个时间间隔分别反标准化（使用对应的scaler）
   - 使用循环：`for i, horizon in enumerate(PREDICTION_HORIZONS)`

#### **STEP 7: 自回归预测 - 多时间间隔预测** ✅ **已完成**

**已实现的内容**：

1. **预测结果提取** ✅
   - 已提取7个时间间隔的收益率：`pred_returns_scaled = pred_tensor[0, 0:NUM_HORIZONS]`
   - 为每个时间间隔分别反标准化
   - 使用1天预测（`pred_returns_denorm[0]`）进行自回归循环
   - 其他时间间隔可用于验证或更复杂的策略

2. **蒙特卡洛模拟** ✅
   - 使用1天预测进行蒙特卡洛模拟
   - 波动率按时间平方根缩放

#### **STEP 8: 场景回测 - 多时间间隔评估** ✅ **已完成**

**已实现的内容**：

1. **目标变量构建** ✅
   - 构建7个时间间隔的目标变量（与STEP 2一致）
   - 使用字典形式的scaler（`local_scaler_target[horizon]`）

2. **模型创建** ✅
   - 使用DualTowerPatternAwareLSTM模型（支持多时间间隔输出）
   - 使用combined_loss损失函数（多时间间隔加权MSE）

3. **预测结果提取** ✅
   - 提取7个时间间隔的收益率：`pred_returns_scaled = pred_ret[0, 0:NUM_HORIZONS]`
   - 为每个时间间隔分别反标准化
   - 使用1天预测进行自回归

#### **STEP 6: 综合可视化 - 多时间间隔可视化** ✅ **已完成**

**已实现的内容**：
- STEP 4中为每个时间间隔分别输出评估指标
- 多时间间隔评估结果以表格形式展示
- 包含所有7个时间间隔的MAE、RMSE、R²对比

#### **实现总结** ✅

**已完成所有修改步骤**：
1. ✅ STEP 2: 目标变量构建（多时间间隔 + 独立scaler）
2. ✅ STEP 3: 模型输出层和损失函数（7维输出 + 加权MSE）
3. ✅ STEP 4: 预测结果提取和评估指标（多时间间隔评估）
4. ✅ STEP 7: 自回归预测中的预测结果提取（提取7个时间间隔，使用1天进行自回归）
5. ✅ STEP 8: 场景回测（多时间间隔支持）
6. ✅ STEP 9: 多时间间隔可视化（直接使用模型输出）

#### **关键技术实现**

1. **标准化一致性** ✅: 每个时间间隔使用独立的scaler（字典形式），已保存和加载
2. **模型兼容性** ✅: 模型配置包含`num_horizons`和`prediction_horizons`信息
3. **性能优化** ✅: 使用加权MSE，短期权重更高，平衡不同时间间隔的重要性
4. **自回归策略** ✅: 使用1天预测进行自回归，其他时间间隔用于验证

---

### 🔴 **高优先级**

---

### 🟡 **中优先级**

#### 5. **动态权重评估优化**
**问题**：
- 当前动态权重计算基于R²，但R²可能为负，导致权重计算不稳定
- 没有考虑模型性能的置信区间

**建议修改**：
- 使用更稳健的权重计算方法（如使用MAE的倒数）
- 考虑使用交叉验证的R²（更稳健）
- 添加权重平滑机制（避免权重剧烈变化）

---

#### 6. **逻辑截断策略优化**
**问题**：
- 当前逻辑截断使用中位数方法，可能不够灵活
- 性能验证只测试了收益率模型，没有测试波动率模型

**建议修改**：
- 同时测试收益率和波动率模型的性能
- 使用加权平均（而不是中位数）确定最终特征数
- 考虑使用更复杂的决策规则（如多目标优化）

---

#### 7. **特征重要性可视化增强**
**问题**：
- 当前可视化只显示Top 30特征
- 没有显示特征筛选前后的对比

**建议修改**：
- 添加特征筛选前后的对比图
- 显示所有筛选后的特征（不仅仅是Top 30）
- 添加特征重要性随时间变化的分析（如果有多期数据）

---

#### 8. **性能评估指标扩展**
**问题**：
- 当前只评估R²和MSE
- 没有评估方向准确率、夏普比率等金融指标

**建议修改**：
- 添加方向准确率评估
- 添加夏普比率、最大回撤等金融指标
- 添加特征筛选前后的策略回测对比

---

### 🟢 **低优先级**

#### 9. **代码模块化**
**问题**：
- 所有代码都在一个notebook中，不利于维护和复用

**建议修改**：
- 将特征筛选逻辑提取为独立函数/类
- 将模型定义提取为独立模块
- 将可视化代码提取为独立函数

---

#### 10. **文档完善**
**问题**：
- 代码注释不够详细
- 缺少使用说明

**建议修改**：
- 添加详细的函数文档字符串
- 创建使用说明文档
- 添加示例代码

---

#### 11. **错误处理增强**
**问题**：
- 某些地方缺少错误处理（如文件加载失败）

**建议修改**：
- 添加try-except块
- 添加更友好的错误提示
- 添加数据验证（如检查数据完整性）

---

#### 12. **计算效率优化**
**问题**：
- 特征筛选过程中，RandomForest训练可能较慢
- 自回归预测中，每天重新计算所有特征可能较慢

**建议修改**：
- 使用并行计算（n_jobs=-1）
- 考虑缓存特征计算结果
- 优化特征计算顺序（先计算依赖少的特征）

---

## 📝 修改建议优先级总结

### **近期修改（提升稳定性）**
5. 动态权重评估优化（提升权重计算稳健性）
6. 逻辑截断策略优化（提升特征选择质量）

### **长期改进（提升用户体验）**
7. 特征重要性可视化增强
8. 性能评估指标扩展
9. 代码模块化
10. 文档完善
11. 错误处理增强
12. 计算效率优化

---

## 🎯 总结

### **已完成的核心功能**
✅ **Permutation Importance特征筛选系统**（全局扫描 → 共线性剪枝 → Permutation Importance评估 → 并集保留策略 → 逻辑截断）⭐ **核心改进**
  - 使用Permutation Importance替代MDI（基于模型预测能力下降量）
  - 多任务独立评估（收益率和波动率分别计算）
  - 并集保留策略（各取Top 40，合并去重）
  - 稳定性增强（n_repeats=10，多次打乱取均值）
  - MDI vs Permutation Importance对比可视化
✅ **多时间间隔LSTM模型**（7个时间间隔收益率 + 波动率）⭐ **新增**
✅ 双重注意力机制（Pattern Attention + Multi-Scale Time Attention）
✅ 自回归预测（动态特征工程 + 蒙特卡洛模拟 + 多时间间隔支持）
✅ 场景回测（使用预训练模型 + 特征一致性保证 + 多时间间隔支持）
✅ 多时间点预测可视化（STEP 9，直接使用模型输出的多时间间隔预测）
✅ 严格的数据泄露防护
✅ 多时间间隔独立标准化（字典形式scaler）
✅ STEP 8特征筛选与STEP 1.5的一致性（已解决）
✅ 特征对齐机制的健壮性（已完善）
✅ 模型加载时的特征数量验证（已添加）
✅ 动态特征筛选结果保存（已实现）

### **系统优势**
- **Permutation Importance评估**：基于模型预测能力下降量，更直接反映特征对预测的实际贡献
- **并集保留策略**：确保收益率和波动率两个任务的重要特征都被保留，避免一方特征数量枯竭
- **稳定性增强**：通过n_repeats多次打乱取均值，消除随机性干扰
- **自动化特征筛选**：减少人工干预，基于数据驱动的方法
- **逻辑截断**：基于多指标自动确定特征数，剔除边际贡献小的特征
- **严格的数据泄露防护**：确保预测的可靠性
- **完整的预测流程**：从数据获取到结果输出

---

**最后更新**: 2025-01-XX
**版本**: v3.1（包含**Permutation Importance特征筛选** + 多品种适配 + **多时间间隔预测** + 蒙特卡洛模拟 + 波动率不确定性量化 + STEP 9可视化）

**当前实现状态**：
- ✅ **Permutation Importance特征筛选**（替代MDI，基于模型预测能力下降量）
- ✅ **并集保留策略**（各取Top 40，合并去重，确保两个任务的重要特征都被保留）
- ✅ **多时间间隔预测**（7个时间间隔：1, 5, 10, 15, 20, 25, 30天收益率 + 波动率）
- ✅ 模型同时输出8维：7个收益率 + 1个波动率
- ✅ 每个时间间隔独立标准化（字典形式scaler）
- ✅ 加权损失函数（短期权重更高）
- ✅ 多时间间隔评估（每个时间间隔独立计算MAE、RMSE、R²）
- ✅ MDI vs Permutation Importance对比可视化（识别被低估的黑马特征）

## 🆕 最新更新内容

### **多时间间隔预测实现** ✅ **v3.0核心功能**

#### **实现概述**
系统已从单时间间隔预测（1天）升级为多时间间隔预测（7个时间间隔：1, 5, 10, 15, 20, 25, 30天），模型同时输出7个时间间隔的收益率和1个波动率。

#### **关键技术实现**

1. **目标变量构建**（STEP 2）
   - 定义`PREDICTION_HORIZONS = [1, 5, 10, 15, 20, 25, 30]`
   - 为每个时间间隔构建独立的目标变量：`target_returns_dict[f'Target_Returns_{horizon}D']`
   - y_raw维度：8列 = [7个收益率, 1个波动率]

2. **独立标准化**（STEP 2）
   - 为每个时间间隔创建独立的`StandardScaler`（字典形式）
   - `scaler_target_returns[horizon]`：7个独立的scaler
   - 保存为字典形式到`scaler_target_returns.pkl`

3. **模型架构**（STEP 3）
   - 收益率塔输出层：`nn.Linear(hidden_size // 2, NUM_HORIZONS)` → 输出7维
   - 最终输出：8维 = [7个收益率, 1个波动率]
   - 模型配置包含`num_horizons`和`prediction_horizons`

4. **加权损失函数**（STEP 3）
   - 时间间隔权重：`[1.0, 0.8, 0.6, 0.5, 0.4, 0.3, 0.2]`（短期权重更高）
   - 方向损失仅使用1天收益率
   - 公式：`loss_returns = Σ(horizon_weights[i] × MSE(pred[i], target[i])) / sum(horizon_weights)`

5. **多时间间隔评估**（STEP 4）
   - 为每个时间间隔分别计算MAE、RMSE、R²
   - 为每个时间间隔分别反标准化
   - 输出格式包含所有7个时间间隔的评估结果

6. **自回归策略**（STEP 7）
   - 提取7个时间间隔的预测值
   - 使用1天预测（`pred_returns_denorm[0]`）进行自回归循环
   - 其他时间间隔可用于验证或更复杂的策略

7. **场景回测支持**（STEP 8）
   - 构建多时间间隔目标变量
   - 使用字典形式的scaler
   - 使用DualTowerPatternAwareLSTM模型和combined_loss

8. **可视化增强**（STEP 9）
   - 直接使用模型输出的多时间间隔预测值
   - 可视化1天、15天、30天的预测结果
   - 自动加载字典形式的scaler

#### **实现优势**
- ✅ **同时预测多个时间间隔**：一次前向传播获得7个时间间隔的预测
- ✅ **独立标准化**：每个时间间隔使用独立的scaler，保证标准化质量
- ✅ **加权训练**：短期时间间隔权重更高，平衡不同时间间隔的重要性
- ✅ **灵活使用**：自回归使用1天预测，其他时间间隔可用于验证
- ✅ **完整评估**：每个时间间隔独立评估，全面了解模型性能

#### **使用说明**
- 模型输出维度：8维 = [7个收益率, 1个波动率]
- Scaler加载：`scaler_target_returns`是字典，使用`scaler_target_returns[horizon]`访问
- 预测提取：`pred[:, 0:NUM_HORIZONS]`为收益率，`pred[:, NUM_HORIZONS]`为波动率
- 反标准化：为每个时间间隔分别反标准化

---

### **多品种适配 + 期货数据** ✅
- VIX获取逻辑优化：优先使用^VIX，失败用^HSIL，都失败用主标的自身波动率估算
- **期货数据整合**：添加了15+种期货数据
  - 股指期货：ES, NQ, YM（领先指标）
  - 商品期货：黄金、白银、原油、铜、天然气
  - 国债期货：ZB（30年）、ZN（10年）
  - 外汇期货：EUR/USD, USD/JPY
- 期货收益率计算：自动计算所有期货的收益率
- 期货特征：ES/SPX价差、期货相关性等领先指标特征
- 外部数据容错处理：所有数据缺失时，相关特征自动设为0或中性值
- 支持ETF、科技股、能源股、A股等各类品种

### **不同到期日期货数据获取方法** ⭐ **新增**

由于yfinance通常只提供近月合约（Front Month），要获取15天、1个月等不同到期日的期货数据，代码采用了以下方法：

1. **获取近月合约数据**
   - 使用`ES=F`、`NQ=F`等获取近月合约价格

2. **计算期限结构（Term Structure）**
   - 计算ES期货与SPX现货的基差（Basis）：`ES_SPX_Basis = (ES_Close - SPX_Close) / SPX_Close * 100`
   - 基差反映期货的溢价/折价，体现期限结构

3. **推断不同到期日的价格**
   - **15天期货**：`ES_15D_Close = ES_FrontMonth_Close * (1 + Basis * 15/30)`
   - **1个月期货**：`ES_1M_Close = ES_FrontMonth_Close * (1 + Basis)`
   - 基于线性期限结构假设（简化模型）

4. **期限结构特征**
   - 期限结构斜率：反映不同到期日期货的价差
   - 基差变化率：反映期限结构的变化趋势

**注意事项**：
- 这是基于期限结构的推断值，不是真实的不同到期日合约价格
- 如需精确的不同到期日数据，建议使用专门的期货数据API（如Quandl, CME Group API）
- 对于CME期货，可以使用具体合约代码（如ESZ2024表示2024年12月合约），但yfinance可能不支持

### **波动率在自回归预测中的作用** ⭐
波动率不仅是模型的双目标之一，更在自回归预测中发挥关键作用：

1. **量化预测不确定性**
   - 模型预测的波动率（pred_vol_pct）作为蒙特卡洛模拟的标准差（sigma）
   - 反映模型对预测的信心程度：高波动率 = 高不确定性，低波动率 = 高置信度

2. **生成价格分布**
   - 使用正态分布：`random_returns = np.random.normal(loc=mu, scale=sigma)`
   - mu = 预测收益率（均值），sigma = 预测波动率（标准差）
   - 生成N次（默认100次）随机收益率，得到价格分布

3. **计算置信区间**
   - 通过模拟结果的分位数计算置信区间
   - 5%分位数 = 悲观情景（低价格）
   - 50%分位数 = 中位数预测（最可能价格）
   - 95%分位数 = 乐观情景（高价格）

4. **风险评估**
   - 高波动率预测 → 价格分布更分散 → 风险更高
   - 低波动率预测 → 价格分布更集中 → 风险更低
   - 帮助投资者理解预测的不确定性范围

